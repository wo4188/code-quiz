[2755. 深度合并两个对象 - 力扣（LeetCode）](https://leetcode.cn/problems/deep-merge-of-two-objects/description/)



<h2 id="R0loQ">题目描述</h2>
给定两个值 `obj1` 和 `obj2`，返回一个 **深度合并** 的值。

你应该遵循以下规则进行值的 **深度合并**：

+ 如果两个值都是对象，则结果对象应包含两个对象上存在的所有键。
+ 如果一个键同时存在于两个对象中，则 **深度合并** 两个关联的值。否则，将键值对添加到结果对象中。
+ 如果两个值都是数组，则结果数组的长度应与较长的数组相同。对于对象的合并逻辑，将索引视为键。
+ 否则，结果值为 `obj2`。

你可以假设 `obj1` 和 `obj2` 是 `JSON.parse()` 的输出结果。



```javascript
type JSONValue =
  | null //
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function deepMerge(obj1: JSONValue, obj2: JSONValue): JSONValue {
  // 处理情况分3种(返回 递归合并的结果)
  // 情况1 🚩 都是数组    ➡️ 取数组长度最大值，索引即键，深度合并
  // 情况2 🚩 都是对象    ➡️ 深度合并所有键
  // 情况3 🚩 其余情况    ➡️ 返回 obj2

  // 都是数组
  if (Array.isArray(obj1) && Array.isArray(obj2)) {
    const arrRsult: JSONValue[] = [];
    const maxLen = Math.max(obj1.length, obj2.length);

    for (let i = 0; i < maxLen; i++) {
      if (i < obj2.length) {
        arrRsult[i] = deepMerge(obj1[i], obj2[i]);
      } else {
        // 表明 obj1.length > obj2.length
        arrRsult[i] = obj1[i];
      }
    }

    return arrRsult;
  }

  // 都是对象
  if (isPureObj(obj1) && isPureObj(obj2)) {
    const objResult = { ...obj1 };

    for (const k of Object.keys(obj2)) {
      if (Object.hasOwn(obj1, k)) {
        objResult[k] = deepMerge(obj1[k], obj2[k]);
      } else {
        objResult[k] = obj2[k];
      }
    }

    return objResult;
  }

  // 其余情况
  // (包括 "数组+对象" 的情况)
  return obj2;
}

function isPureObj(obj: unknown): obj is Record<string, unknown> {
  return (
    typeof obj === 'object' && //
  obj !== null &&
  !Array.isArray(obj)
);
}

```



<details class="lake-collapse"><summary id="uadd10fc9"><strong><em><span class="ne-text">输入输出示例</span></em></strong></summary><p id="ud86df498" class="ne-p"><span class="ne-text">示例 1：</span></p><pre data-language="plain" id="u1euH" class="ne-codeblock language-plain"><code>输入：obj1 = {&quot;a&quot;: 1, &quot;c&quot;: 3}, obj2 = {&quot;a&quot;: 2, &quot;b&quot;: 2}
输出：{&quot;a&quot;: 2, &quot;c&quot;: 3, &quot;b&quot;: 2}
解释：obj1[&quot;a&quot;] 的值变为 2，因为如果两个对象具有相同的键且它们的值不是数组或对象，则将 obj1 的值更改为 obj2 的值。键 &quot;b&quot; 和其值被添加到 obj1 中，因为它在 obj1 中不存在。 </code></pre><p id="u03e7512c" class="ne-p"><span class="ne-text">示例 2：</span></p><pre data-language="plain" id="V5VEX" class="ne-codeblock language-plain"><code>输入：obj1 = [{}, 2, 3], obj2 = [[], 5]
输出：[[], 5, 3]
解释：result[0] = obj2[0]，因为 obj1[0] 和 obj2[0] 类型不同。result[2] = obj1[2]，因为 obj2[2] 不存在。</code></pre><p id="udd5e855b" class="ne-p"><span class="ne-text">示例 3：</span></p><pre data-language="plain" id="l3v7z" class="ne-codeblock language-plain"><code>输入：
obj1 = {&quot;a&quot;: 1, &quot;b&quot;: {&quot;c&quot;: [1 , [2, 7], 5], &quot;d&quot;: 2}}, 
obj2 = {&quot;a&quot;: 1, &quot;b&quot;: {&quot;c&quot;: [6, [6], [9]], &quot;e&quot;: 3}}
输出：{&quot;a&quot;: 1, &quot;b&quot;: {&quot;c&quot;: [6, [6, 7], [9]], &quot;d&quot;: 2, &quot;e&quot;: 3}}
解释：
数组 obj1[&quot;b&quot;][&quot;c&quot;] 和 obj2[&quot;b&quot;][&quot;c&quot;] 已合并，如果 obj2 的值不是数组或对象，则深度覆盖 obj1 的值。 obj2[&quot;b&quot;][&quot;c&quot;] 有键 &quot;e&quot;，而 obj1 中没有，所以将其添加到 obj1 中。</code></pre><p id="ua53ca0e1" class="ne-p"><span class="ne-text">示例 4：</span></p><pre data-language="plain" id="Llil1" class="ne-codeblock language-plain"><code>输入：obj1 = true, obj2 = null
输出：null</code></pre></details>
